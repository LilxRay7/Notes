# [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

**6-15二刷，本质上也是一个划分的过程，比如有三个节点时，以第一个节点为根节点，有 dp[0] * dp[2] 种划分；以第二个节点为根节点，有 dp[1] * dp[1] 种划分；以第三个节点为根节点，有 dp[2] * dp[0] 种划分。他们都是不同的树，所以将结果累加起来。**

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

**示例 1：**

![img](../../Images/7.不同的二叉搜索树.assets/uniquebstn3.jpg)

```
输入：n = 3
输出：5
```

**示例 2：**

```
输入：n = 1
输出：1 
```

**提示：**

- `1 <= n <= 19`

### 动态规划

**递推公式：dp[i] += dp[j - 1] * dp[i - j];** 

**j - 1 为 j 为头结点左子树节点数量，i - j 为以 j 为头结点右子树节点数量。**

![96.不同的二叉搜索树2](../../Images/7.不同的二叉搜索树.assets/20210107093226241.png)

![96.不同的二叉搜索树3](../../Images/7.不同的二叉搜索树.assets/20210107093253987.png)

```c++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        for (int i = 1; i <= n; i++)
            for (int j = 1; j <= i; j++) 
                dp[i] += dp[j - 1] * dp[i - j];
        return dp[n];
    }
};
```

