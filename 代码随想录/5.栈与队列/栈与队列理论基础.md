# 栈与队列理论基础



![栈与队列理论1](../../Images/栈与队列理论基础.assets/20210104235346563.png)

### 我们使用的stack是属于那个版本的STL？

C++标准库是有多个版本的，要知道我们使用的STL是哪个版本，才能知道对应的栈和队列的实现原理。

三个最为普遍的STL版本：

1. HP STL 及其他版本的C++ STL，一般是以HP STL为蓝本实现出来的，HP STL是C++ STL的第一个实现版本，而且开放源代码。
2. P.J.Plauger STL 由P.J.Plauger参照HP STL实现出来的，被Visual C++编译器所采用，不是开源的。
3. SGI STL 由Silicon Graphics Computer Systems公司参照HP STL实现，被Linux的C++编译器GCC所采用，SGI STL是开源软件，源码可读性甚高。

接下来介绍的栈和队列也是SGI STL里面的数据结构， 知道了使用版本，才知道对应的底层实现。

### 栈

栈先进后出，如图所示：

![栈与队列理论2](../../Images/栈与队列理论基础.assets/20210104235434905.png)

栈提供 push 和 pop 等等接口，所有元素必须符合先进后出规则，所以栈不提供走访功能，也不提供迭代器(iterator)。 不像是 set 或者 map 提供迭代器 iterator 来遍历所有元素。

**栈是以底层容器完成其所有的工作，对外提供统一的接口，底层容器是可插拔的（也就是说我们可以控制使用哪种容器来实现栈的功能）。**

所以 STL 中栈往往不被归类为容器，而被归类为 container adapter（容器适配器）。

那么问题来了，STL 中栈是用什么容器实现的？

从下图中可以看出，栈的内部结构，栈的底层实现可以是 vector，deque，list 都是可以的， 主要就是数组和链表的底层实现。

![栈与队列理论3](../../Images/栈与队列理论基础.assets/20210104235459376.png)

**我们常用的 SGI STL，如果没有指定底层实现的话，默认是以 deque 为缺省情况下栈的低层结构。**

deque 是一个双向队列，只要封住一段，只开通另一端就可以实现栈的逻辑了。

**SGI STL 中队列底层实现缺省情况下一样使用  deque 实现的。**

我们也可以指定 vector 为栈的底层实现，初始化语句如下：

```text
std::stack<int, std::vector<int> > third;  // 使用vector为底层容器的栈
```

### 队列

队列中先进先出的数据结构，同样不允许有遍历行为，不提供迭代器, **SGI STL 中队列一样是以 deque 为缺省情况下的底部结构。**

也可以指定 list 为起底层实现，初始化 queue 的语句如下：

```text
std::queue<int, std::list<int>> third; // 定义以list为底层容器的队列
```

所以 STL 队列也不被归类为容器，而被归类为 container adapter（ 容器适配器）。

**面试题：栈里面的元素在内存中是连续分布的么？**

- 陷阱1：栈是容器适配器，底层容器使用不同的容器决定了数据在内存中是不是连续分布。
- 陷阱2：缺省情况下，默认底层容器是deque，那么deque的在内存中的数据分布是什么样的呢？ 答案是：不连续的。

### 栈在系统中的应用

编译器在词法分析的过程中处理括号、花括号等符号的逻辑，就使用了栈这种数据结构。

举例，linux 系统中，cd 进入目录的命令：

```text
cd a/b/c/../../
```

这个命令最后进入 a 目录，系统是如何知道进入了 a 目录呢 ，这就是栈的应用。

**递归的实现是栈：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。**

所以栈在计算机领域中应用是非常广泛的！