# 二叉树理论基础

题目分类大纲如下：

![二叉树大纲](../../Images/二叉树理论基础.assets/20210219190809451.png)

### 二叉树的种类

在解题中二叉树有两种主要的形式：**满二叉树**和**完全二叉树**。

### 满二叉树

如果一棵二叉树只有度为 0 和 2 的结点，并且度为 0 的结点在同一层上，则这棵二叉树为满二叉树。

![img](../../Images/二叉树理论基础.assets/20200806185805576.png)

这棵二叉树为满二叉树，也可以说深度为 k ，有$2^k-1$个节点的二叉树。

### 完全二叉树

定义：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ $2^h$ -1  个节点。

![img](../../Images/二叉树理论基础.assets/20200920221638903.png)

**之前的优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系。**

### 二叉搜索树

前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，**二叉搜索树是一个有序树**。

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树。

![img](../../Images/二叉树理论基础.assets/20200806190304693.png)

### 平衡二叉搜索树

又被称为AVL（Adelson-Velsky and Landis）树，具有以下性质：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

![img](../../Images/二叉树理论基础.assets/20200806190511967.png)

最后一棵不是平衡二叉树，因为它的左右两个子树的高度差的绝对值超过了1。

**C++中 map、set、multimap、multiset 的底层实现都是平衡二叉搜索树**，所以 map、set 的增删操作时间时间复杂度是 $log(n)$，注意我这里没有说 unordered_map、unordered_set，其底层实现是**哈希表**。

**所以写算法，一定要知道常用的容器底层都是如何实现的，最基本的就是 map、set 等等，否则难以对其性能分析。**

### 二叉树的存储方式

**二叉树可以链式存储，也可以顺序存储。**

链式存储方式就用**指针**，顺序存储的方式就是用**数组**。

顺序存储的元素在内存是**连续分布**的，而链式存储则是通过**指针**把散落在各个地址的节点串联一起。

链式存储：

![img](../../Images/二叉树理论基础.assets/2020092019554618.png)

顺序存储：

![img](../../Images/二叉树理论基础.assets/20200920200429452.png)

用数组来存储二叉树如何遍历的呢？

**如果父节点的数组下标是 i，那么它的左孩子就是 i * 2 + 1，右孩子就是 i * 2 + 2。**

但是用链式表示的二叉树，更有利于理解，所以一般都是用链式存储二叉树。

**所以要了解，用数组依然可以表示二叉树。**

### 二叉树的遍历方式

二叉树主要有两种遍历方式：

- 深度优先遍历：先往深走，遇到叶子节点再往回走。
- 广度优先遍历：一层一层的去遍历。

**这两种遍历是图论中最基本的两种遍历方式。**

从深度优先遍历和广度优先遍历进一步拓展，有如下遍历方式：

- 深度优先遍历
  - 前序遍历（递归法，迭代法）
  - 中序遍历（递归法，迭代法）
  - 后序遍历（递归法，迭代法）
- 广度优先遍历
  - 层次遍历（迭代法）

**左节点一定优先于右结点遍历，而中间节点的顺序就是所谓的遍历方式：**

- 前序遍历：中左右
- 中序遍历：左中右
- 后序遍历：左右中

![img](../../Images/二叉树理论基础.assets/20200806191109896.png)

做二叉树相关题目时，经常会使用**递归的方式来实现深度优先遍历**（前中后序遍历），是比较方便的。

**由于栈就是递归的一种实现结构**，所以前中后序遍历其实都可以借助栈使用非递归的方式来实现的。

而**广度优先遍历的实现一般使用队列来实现**，这是由队列先进先出的特点所决定的，因为需要先进先出的结构，才能一层一层的来遍历二叉树。

### 二叉树的定义

顺序存储就是用数组来定义，链式存储的二叉树节点的定义方式如下（C++）：

```c++
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

二叉树的定义和链表相似，相对于链表，二叉树的节点里多了一个指针，有两个指针，指向左右孩子。

**在现场面试的时候可能要求手写代码，所以数据结构的定义以及简单逻辑的代码一定要能手写出来**

**在刷leetcode的时候，节点的定义默认都定义好了，面试如果需要自己定义节点可能会一脸懵逼！**